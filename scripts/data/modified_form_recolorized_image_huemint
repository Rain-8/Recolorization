import os
import json
from PIL import Image
import numpy as np
from scipy.spatial import KDTree
from skimage.color import rgb2lab, lab2rgb, rgb2hsv, hsv2rgb
from tqdm import tqdm
from Pylette import extract_colors


def extract_top_colors(image_path, num_colors=8):
    """Extracts the top colors from the image as RGB tuples."""
    colors = extract_colors(image_path, num_colors)
    return [tuple(map(int, x.rgb)) for x in colors]  # Convert to integer RGB tuples


def adjust_palette_diversity(src_palette, num_colors=10):
    """Extend or adjust palette for a more even color distribution."""
    if len(src_palette) < num_colors:
        extended_palette = []
        step = max(1, len(src_palette) // num_colors)
        for color in src_palette[::step]:
            extended_palette.append(color)
        src_palette = extended_palette[:num_colors]
    return src_palette


def replace_colors_adaptive(image_path, src_palette, tgt_palette, distance_threshold=30):
    """
    Replace colors in an image by blending colors based on proximity to source palette
    using KDTree for fast nearest neighbor lookup. Adaptive blending applied.
    """
    # Open the image and convert to NumPy array
    image = Image.open(image_path).convert("RGB")
    pixels = np.array(image, dtype=np.float32).reshape(-1, 3)  # Flattened array
    
    # Create KDTree from the source palette
    src_palette_tree = KDTree(src_palette)
    
    # Perform a nearest-neighbor search for each pixel
    distances, src_indices = src_palette_tree.query(pixels)
    
    # Convert palettes to arrays for efficient access
    src_palette = np.array(src_palette, dtype=np.float32)
    tgt_palette = np.array(tgt_palette, dtype=np.float32)

    # Initialize the output with the original pixel values
    recolored_pixels = pixels.copy()
    
    # For each pixel, calculate the weight for blending and apply the target color blend
    within_threshold = distances < distance_threshold
    weights = 1 - (distances[within_threshold] / distance_threshold)
    recolored_pixels[within_threshold] = (
        (1 - weights[:, None]) * pixels[within_threshold] +
        weights[:, None] * tgt_palette[src_indices[within_threshold]]
    )

    # Reshape recolored pixels to original image shape and convert back to uint8
    recolored_pixels = recolored_pixels.reshape(image.size[1], image.size[0], 3).astype(np.uint8)
    
    # Convert back to PIL image
    recolored_image = Image.fromarray(recolored_pixels)
    return recolored_image


def hex_to_rgb(hex_color):
    """Convert HEX color to RGB tuple."""
    return tuple(int(hex_color[i:i+2], 16) for i in (1, 3, 5))


def process_images(src_dir, tgt_dir):
    os.makedirs(tgt_dir, exist_ok=True)
    os.makedirs(f"{tgt_dir}/src_images", exist_ok=True)
    os.makedirs(f"{tgt_dir}/tgt_images", exist_ok=True)
    json_data = {}
    image_paths = sorted(glob.glob(f"{src_dir}/*"))

    for image_path in tqdm(image_paths):
        try:
            image_name = os.path.basename(image_path).split(".")[0]
            original_image_path = os.path.join(tgt_dir, f"src_images/{image_name}.png")

            # Copy original image to target directory
            Image.open(image_path).convert("RGB").save(original_image_path)

            # Step 1: Extract top colors from the image
            top_colors = extract_top_colors(image_path, num_colors=8)
            top_colors = adjust_palette_diversity(top_colors, num_colors=10)  # Adjust for more even color distribution

            # Assuming contrast_matrix_flat_list and get_huemint_response are provided
            adjacency_matrix = contrast_matrix_flat_list(top_colors)
            response = get_huemint_response(adjacency_matrix, len(top_colors))
            if response is not None:
                for idx, result in enumerate(response["results"][:140]):
                    tgt_palette = [hex_to_rgb(color) for color in result["palette"]]
                    recolored_image_name = f"tgt_images/recolor_{image_name}_palette_{idx}.png"
                    recolored_image_path = os.path.join(tgt_dir, recolored_image_name)
                    
                    try:
                        recolorized_image = replace_colors_adaptive(
                            image_path, top_colors, tgt_palette, distance_threshold=35
                        )
                        recolorized_image.convert("RGB").save(recolored_image_path)
                    except Exception as recolor_error:
                        print("Recoloring failed:", recolor_error)
                        continue

                    # JSON structure for tracking data
                    json_key = f"{image_name}_palette_{idx}"
                    json_data[json_key] = {
                        "src_image_path": original_image_path,
                        "src_palette": [[int(c) for c in color] for color in top_colors],
                        "tgt_palette": [[int(c) for c in color] for color in tgt_palette],
                        "tgt_image_path": recolored_image_path
                    }
        except Exception as e:
            print("Error: ", e)

    # Save JSON to file
    json_output_path = os.path.join(tgt_dir, "recolorization_data.json")
    with open(json_output_path, "w") as json_file:
        json.dump(json_data, json_file)
    print(f"JSON data saved to {json_output_path}")


# Main script
if __name__ == "__main__":
    src_dir = "../../datasets/raw_recolor_data_sample/"  # Directory containing source images
    tgt_dir = "../../datasets/processed_palettenet_data_sample/"  # Directory to save recolorized images and palettes

    for split in ["train", "val", "test"]:
        process_images(f"{src_dir}{split}", f"{tgt_dir}{split}")
